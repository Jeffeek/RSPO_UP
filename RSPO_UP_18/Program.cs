using System;
using System.Collections.Generic;
using System.Linq;

namespace RSPO_UP_18
{
    /*
       Создать заданный в варианте обобщенный класс. Определить в классе индексаторы,
       конструкторы, деструктор, необходимые функции и заданные операции (внутри
       использовать ключевое слово dynamic). Используйте обработку исключительных
       ситуаций и генерацию. ДЛЯ РЕШЕНИЯ ЗАДАНИЙ ИСПОЛЬЗОВАТЬ МАССИВЫ
     * Класс – множество Сset. Дополнительно перегрузить следующие операции: + – добавить
       элемент в множество (пример set + item); * – пересечение множеств, ==, != – проверка
       множеств на равенство, неравенство. Поиск разности множеств.
       Генерация события по добавлению элемента в множество В обработчике получать
       значение старого и нового элемента
     */

    /*
     * Работа производится над объектом содержащим массив обобщенных коллекций
       (указанную в задании). На каждый элемент массива надо указать ограничения указанное в
       задании. В отдельных методах объекта выполнить указанные ниже запросы.
       создать объект CollectionType&lt;T&gt;, содержащий массив обобщённых
       коллекций, запросы - найти количество коллекций равных заданному
       размеру, найти максимальную и минимальную коллекцию(по
       количеству указных значений элемента) в массиве. Отсортировать
       массив по общей сумме свойства count в коллекции, учитывая, что
       каждый элемент коллекции реализует интерфейс ICount{int count}.
       Обобщенная коллекция – List&lt;T&gt;.
     */

    class Program
    {
        static void Main(string[] args)
        {
            var collections = new List<List<int>>();
            var random = new Random();
            for (var i = 0; i < 100; i++)
            {
                collections[i] = new List<int>();
                for (var j = 0; j < 100; j++)
                    collections[i].Add(random.Next(-50, 50));
            }

            // 1
            var N = 35;
            var filtered = collections.Count(x => x.Count == N);
            // 2
            var min = collections.Min(x => x.Count);
            var max = collections.Max(x => x.Count);
            // 3
            var ordered = collections.OrderBy(x => x.Count);

            Console.ReadLine();
        }
    }
}
